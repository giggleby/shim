# Copyright 2018 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Module for configless fields.

Configless fields are some numeric fields in HWID that can be decoded without
board / project specific database (e.g. HWID database).
"""

import ctypes

import factory_common  # pylint: disable=unused-import
from cros.factory.hwid.v3 import common
from cros.factory.test import device_data


class _FeatureList(ctypes.Structure):
  """Dump/Load feature list according to _fields_ in _FeatureList_{version}"""
  def Dump(self):
    buf = ctypes.create_string_buffer(ctypes.sizeof(self))
    ctypes.memmove(buf, ctypes.addressof(self), ctypes.sizeof(self))
    return buf.raw.encode('hex').upper().replace('0X', '')

  @classmethod
  def Load(cls, buf):
    obj = cls()
    ctypes.memmove(ctypes.addressof(obj), buf.decode('hex'), ctypes.sizeof(obj))
    return obj

  @property
  def features(self):
    return [field[0] for field in self._fields_]


class _FeatureList_0(_FeatureList):
  _fields_ = [
      ('has_touchscreen', ctypes.c_uint8, 1),
      ('has_touchpad', ctypes.c_uint8, 1),
      ('has_stylus', ctypes.c_uint8, 1),
      ('has_front_camera', ctypes.c_uint8, 1),
      ('has_rear_camera', ctypes.c_uint8, 1),
      ('has_fingerprint', ctypes.c_uint8, 1),
      ('is_convertible', ctypes.c_uint8, 1),
      ('is_rma_device', ctypes.c_uint8, 1)
  ]


class ConfiglessFields(object):
  """ConfiglessFields class

  The format of configless fields is decided by FIELDS:

  `hex(<FIELDS[0]>)-hex(<FIELDS[1]>)-...-hex(<FIELDS[-1]>)`

  And the content of feature list field is decided by _FeatureList_{version}
  where version is FIELDS[0].

  For example,

  FIELDS = [
      'version',
      'memory',
      'storage',
      'feature_list'
  ]

  FEATURE_LIST = {
    0: _FeatureList_0,
  }

  encoded string "0-8-74-01" represents version 0, 8G memory, 116G storage and
  has touchscreen.
  """

  FIELDS = [
      'version', # version of feature list
      'memory',
      'storage',
      'feature_list'
  ]

  FEATURE_LIST = {
      0: _FeatureList_0,
  }


  @classmethod
  def Encode(cls, db, bom, device_info, version):
    """Return a encoded string according to version.

    Args:
      db: a Database object that is used to provide device-specific
          information.
      :type database: cros.factory.hwid.v3.database.Database

      bom: a BOM object that lists components on current device.
      :type bom: cros.factory.hwid.v3.bom.BOM

      device_info: a dictionary follows definition in `device_data`.
      :type device_info: dict

      version: use _FeatureList_{version} to encode/decode feature list field.
      :type version: int

    Returns:
      A string of encoded configless fields.
    """
    feature_list = cls.FEATURE_LIST[version]
    getter = _ConfiglessFieldGetter(db, bom, device_info, version,
                                    feature_list())
    return '-'.join(getter(field) for field in cls.FIELDS)

  @classmethod
  def Decode(cls, encoded_string):
    """Return a dict of decoded info.

    Args:
      encoded_string: a string generated by ConfiglessFields.Encode
      :type encoded_string: string

    Returns:
      A decoded dict.
      For example, a return dict
      {
          'version': 0,
          'memory': 8,
          'storage' 116,
          'feature_list': {
              'has_touchscreen': 1,
              'has_touchpad': 0,
              'has_stylus': 0,
              'has_front_camera': 0,
              'has_rear_camera': 0,
              'has_fingerprint': 0,
              'is_convertible': 0,
              'is_rma_device': 0,
          }
      }
      means configless fileds version 0, 8G memory, 116G storage and has
      touchscreen.
    """
    decoder = _ConfiglessFieldDecoder(encoded_string, cls.FEATURE_LIST)
    fields = {
        field: decoder(field)
        for field in cls.FIELDS
    }
    return fields


class _ConfiglessFieldGetter(object):
  """Extract value of from BOM / device_info for configless fields."""
  def __init__(self, db, bom, device_info, version, feature_list):
    self._db = db
    self._bom = bom
    self._device_info = device_info or {}
    self._version = version
    self._feature_list = feature_list

  def __call__(self, field_name):
    """Get value of a field."""
    return getattr(self, field_name)

  @property
  def memory(self):
    size_mb = sum(int(self._db.GetComponents('dram')[comp].values['size'])
                  for comp in self._bom.components['dram'])
    return hex(size_mb / 1024).upper().replace('0X', '')

  @property
  def storage(self):
    sectors = sum(int(self._db.GetComponents('storage')[comp].values['sectors'])
                  for comp in self._bom.components['storage'])
    # Assume sector size is 512 bytes
    return hex(sectors / 2 / 1024 / 1024).upper().replace('0X', '')

  @property
  def version(self):
    return hex(self._version).upper().replace('0X', '')

  @property
  def feature_list(self):
    """Get feature list encoded string."""
    components = self._device_info.get(device_data.KEY_COMPONENT, {})
    for feature in self._feature_list.features:
      value = components.get(feature, 0)  # default value is 0 (False)
      setattr(self._feature_list, feature, value)
    return self._feature_list.Dump()


class _ConfiglessFieldDecoder(object):
  """Extract value of encoded string for configless fields."""
  def __init__(self, encoded_string, feature_list):
    encoded_fields = encoded_string.split('-')
    if len(encoded_fields) != len(ConfiglessFields.FIELDS):
      raise common.HWIDException(
          'The given configless fields %r is invalid. It must have %r fields.' %
          (encoded_string, len(ConfiglessFields.FIELDS)))

    self._encoded_fields = dict(zip(ConfiglessFields.FIELDS, encoded_fields))
    version = int(self._encoded_fields['version'], 16)
    self._feature_list = feature_list[version].Load(
        self._encoded_fields['feature_list'])

  def __call__(self, field_name):
    """Get decoded value of a field.

    By default, convert encoded hex string to integer.
    To override the behavior, create a property of field name
    (e.g. `feature_list`).
    """
    try:
      return getattr(self, field_name)
    except Exception:
      return int(self._encoded_fields[field_name], 16)

  @property
  def feature_list(self):
    """Construct the dict of feature list"""
    result = {
        feature: getattr(self._feature_list, feature)
        for feature in self._feature_list.features
    }
    return result
