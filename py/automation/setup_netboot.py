#!/usr/bin/env python
# Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import errno
import logging
import optparse
import os
import re
import shutil
import stat
import subprocess
import sys
import tempfile
import time

import factory_common  # pylint: disable=W0611
from cros.factory.utils.process_utils import Spawn


DHCPD_CONF_TEMPLATE = '''# Generated by setup_netboot.py
subnet %(subnet)s netmask %(netmask)s {
  next-server %(host)s;
}
host dut {
  hardware ethernet %(dut_mac)s;
  fixed-address %(dut_address)s;
  %(script_directive)s
}
'''


def ErrorExit(msg):
  logging.error(msg)
  sys.exit(1)


def Call(cmd):
  logging.info(cmd)
  return subprocess.call(cmd, shell=True)


def CheckCall(cmd):
  logging.info(cmd)
  # Do not use subprocess.check_call, which shows annoying stacktrace.
  if subprocess.call(cmd, shell=True) != 0:
    ErrorExit('Run command "%s" failed.' % cmd)


def IsProcessAlive(pat):
  rc = Call('pgrep -f -l %s' % pat)
  return rc == 0


def KillProcess(pat, timeout=5):
  Call('pgrep -f -l %s' % pat)
  killed = False
  Call('sudo pkill -f %s' % pat)
  while timeout > 0:
    if not IsProcessAlive(pat):
      killed = True
      break
    timeout -= 1
    time.sleep(1)
  if not killed and IsProcessAlive(pat):
    ErrorExit('Kill process "%s" failed.' % pat)


def CheckPackagesInstalled():
  required_pkgs = ['app-arch/pigz',
                   'dev-embedded/u-boot-tools',
                   'net-ftp/tftp-hpa',
                   'net-misc/dhcp',
                  ]
  for pkg in required_pkgs:
    if Call('equery list %s' % pkg) != 0:
      ErrorExit('Please install package "%s".' % pkg)


def RemoveFile(path):
  try:
    os.remove(path)
  except OSError as e:
    # Ignore the error 'No such file or directory'.
    # Do not use something like 'if not os.path.exists(path): os.remove(path)',
    # because there is a race condition in this statement.
    if e.errno != errno.ENOENT:
      raise


def ModifyNetbootIP(host, initrd):
  """Modify the server addresses in lsb-factory to our host IP.

  Before:
    CHROMEOS_AUSERVER=http://build51-m2.golo.chromium.org:8080/update
    CHROMEOS_DEVSERVER=http://build51-m2.golo.chromium.org:8080/update
  After: (host IP: 192.168.1.254)
    CHROMEOS_AUSERVER=http://192.168.1.254:8080/update
    CHROMEOS_DEVSERVER=http://192.168.1.254:8080/update
  """
  header = subprocess.Popen('mkimage -l %s' % initrd, shell=True,
                            stdout=subprocess.PIPE).communicate()[0]
  load_address = re.findall('Load Address:\s*(.*)', header)[0]
  entry_point = re.findall('Entry Point:\s*(.*)', header)[0]
  image_name = re.findall('Image Name:\s*(.*)', header)[0]
  with open(initrd, mode='rb') as f:
    f.seek(64)  # skipping initrd header (64 bytes)
    gzipped_rootfs = f.read()
  with tempfile.NamedTemporaryFile(suffix='_rootfs.gz') as tf:
    tf.write(gzipped_rootfs)
    tf.flush()
    td = tempfile.mkdtemp(suffix='_mnt')
    tr = os.path.splitext(tf.name)[0]
    CheckCall('gunzip -d -f "%s"' % tf.name)
    CheckCall('sudo mount -o loop %s %s' % (tr, td))
    CheckCall("sudo sed -i \"s'//.*:'//%s:'\"" % host +
              " %s/mnt/stateful_partition/dev_image/etc/lsb-factory" % td)
    CheckCall('sudo umount -f %s' % td)
    CheckCall('rmdir %s' % td)
    CheckCall('pigz -9 %s' % tr)
    # TODO(shik): Support building ramdisk for ARM platform.
    CheckCall('mkimage -A x86 -O linux -T ramdisk'
              ' -a %s -e %s -n "%s" -C gzip -d %s %s'
              % (load_address, entry_point, image_name, tf.name, initrd))


def GenerateImage(host, port, tftp_dir, script, initrd, vmlinux):
  """Generate the script image which guides the netboot flow
  When netboot starts with command "dhcp", and the script image is set by
  by filename statement in DHCP server configuration, this image will be placed
  in address 0x100000 and executed on DUT by netboot firmware (coreboot.h).
  """
  # TFTP server needs universal read permission.
  mode = stat.S_IWUSR | stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH
  # Place factory install shim onto TFTP server.
  if script:
    td = tempfile.mkdtemp(dir=tftp_dir)
    scriptImg = os.path.join(tftp_dir, script)
    with tempfile.NamedTemporaryFile(suffix='_scriptImage.scr') as tf:
      # Override Omaha URL by passing argument to kernel command line.
      # For more details about how does this work, see factory_install.sh.
      tf.write("setenv bootargs ${bootargs}"
               " 'omahaserver=http://%s:%d/update'\n" % (host, port))
      # Put kernel image at 0x101000 so as not to overlap with the script image.
      tf.write('tftpboot 0x101000 %s/uImage\n' % os.path.basename(td))
      tf.write('tftpboot 0x12008000 %s/rootImg\n' % os.path.basename(td))
      tf.write('bootm 0x101000 0x12008000\n')
      tf.flush()
      RemoveFile(scriptImg)  # this file may be generated by other user
      CheckCall('mkimage -T script -C none -n "Netboot Script Image"'
                ' -d %s %s' % (tf.name, scriptImg))
    os.chmod(scriptImg, mode)
    os.chmod(td, stat.S_IRWXU | stat.S_IXOTH)
  else:
    td = tftp_dir
  uImage = os.path.join(td, 'uImage')
  rootImg = os.path.join(td, 'rootImg')
  shutil.copy(vmlinux, uImage)
  shutil.copy(initrd, rootImg)
  os.chmod(uImage, mode)
  os.chmod(rootImg, mode)
  os.chmod(tftp_dir, stat.S_IRWXU | stat.S_IXOTH)


def StartTFTPServer(host, tftp_dir):
  return Spawn(['/usr/sbin/in.tftpd', '-L', '--address', '%s:69' % host,
                '-s', tftp_dir],
               log=True, sudo=True)


def StartDHCPServer(dhcp_iface, host, subnet, netmask, dut_mac, dut_address,
                    script):
  if script:
    script_directive = 'filename "%s";' % script
  else:
    script_directive = ''
  cfg = tempfile.NamedTemporaryFile(prefix='dhcpd_', suffix='.conf',
                                    delete=False)
  cfg.write(DHCPD_CONF_TEMPLATE % dict(host=host, subnet=subnet,
                                       netmask=netmask, dut_mac=dut_mac,
                                       dut_address=dut_address,
                                       script_directive=script_directive))
  cfg.flush()
  Spawn(['/sbin/ifconfig', dhcp_iface, host], check_call=True, log=True,
        sudo=True)
  Spawn(['touch', '/var/lib/dhcp/dhcpd.leases'], check_call=True, log=True,
        sudo=True)
  return Spawn(['/usr/sbin/dhcpd', '-f', '-cf', cfg.name], log=True, sudo=True)


def CloneMiniomaha(miniomaha_dir):
  """Use cloned Mini-Omaha server to prevent race condition
  When running multiple Mini-Omaha server instance from same directory
  concurrently, they will use the same "static" folder thus hit race condition.
  """
  clone_dir = os.path.join(tempfile.mkdtemp(prefix='miniomaha_'), 'miniomaha')
  shutil.copytree(miniomaha_dir, clone_dir)
  return clone_dir


def MakeFactoryPackage(miniomaha_dir, board, release, factory,
                       hwid_updater, firmware_updater):
  cmd = os.path.join(miniomaha_dir, 'make_factory_package.sh')
  cmd += ' --board="%s"' % board
  cmd += ' --release="%s" --factory="%s"' % (release, factory)
  cmd += ' --hwid_updater="%s"' % hwid_updater
  if firmware_updater:
    cmd += ' --firmware_updater="%s"' % firmware_updater
  CheckCall(cmd)


def StartMiniomahaServer(miniomaha_dir, port):
  # Do not remove the extension ".py" when killing process,
  # or it may kill itself since when arguments is matching this pattern.
  KillProcess('miniomaha.py.*' + str(port))
  cmd = os.path.join(miniomaha_dir, 'miniomaha.py')
  cmd += ' --port %d' % port
  CheckCall(cmd)


def ParseOptions():
  parser = optparse.OptionParser()
  parser.add_option('--miniomaha_dir', help='/path/to/miniomaha_directory')
  parser.add_option('--board', help='Board for which the image was built.')
  parser.add_option('--release', help='/path/to/release_image.bin')
  parser.add_option('--factory', help='/path/to/factory_image.bin')
  parser.add_option('--hwid_updater', help='/path/to/hwid_updater.sh')
  parser.add_option('--firmware_updater', default='',
                    help='/path/to/firmware_updater')
  parser.add_option('--script', default='',
                    help='Script Image name in DHCP configuration.')
  parser.add_option('--initrd', help='/path/to/initrd.uimg')
  parser.add_option('--vmlinux', help='/path/to/vmlinux.uimg')
  parser.add_option('--host', default='192.168.1.254',
                    help='Server IP address. (default: %default)')
  parser.add_option('--port', default=8080, type=int,
                    help='Server port. (default: %default)')
  parser.add_option('--dhcp_iface', default='',
                    help='Network interface to run DHCP server on.')
  parser.add_option('--dhcp_subnet', default='192.168.1.0',
                    help='DHCP subnet. (default: %default)')
  parser.add_option('--dhcp_netmask', default='255.255.255.0',
                    help='DHCP netmask. (default: %default)')
  parser.add_option('--dut_mac', default='', help='DUT MAC address.')
  parser.add_option('--dut_address', default='192.168.1.1',
                    help='DUT IP address. (default: %default)')
  parser.add_option('--color', action='store_true', default=False,
                    help='Show colorful output for logging.')
  parser.add_option('--no_check_packages', dest='do_check_packages',
                    default=True, action='store_false', help='')
  parser.add_option('--do_modify_netboot_ip', dest='do_modify_netboot_ip',
                    default=True, action='store_true', help='')
  parser.add_option('--no_tftp', dest='do_tftp',
                    default=True, action='store_false', help='')
  parser.add_option('--no_dhcp', dest='do_dhcp',
                    default=True, action='store_false', help='')
  parser.add_option('--no_generate_image', dest='do_generate_image',
                    default=True, action='store_false', help='')
  parser.add_option('--no_clone_miniomaha', dest='do_clone_miniomaha',
                    default=True, action='store_false', help='')
  parser.add_option('--no_make_factory_package', dest='do_make_factory_package',
                    default=True, action='store_false', help='')
  parser.add_option('--no_miniomaha', dest='do_miniomaha',
                    default=True, action='store_false', help='')
  options = parser.parse_args()[0]

  log_format = '%(asctime)s - %(levelname)s - %(funcName)s: %(message)s'
  if options.color:
    log_format = '\033[1;33m' + log_format + '\033[0m'
  logging.basicConfig(level=logging.INFO, format=log_format)

  miss_opts = [opt for opt, val in options.__dict__.iteritems() if val == None]
  if miss_opts:
    ErrorExit('Missing argument(s): ' + ', '.join(miss_opts))
  if options.do_dhcp and (not options.dhcp_iface or not options.dut_mac or
                          not options.dut_address):
    ErrorExit('Please specify dhcp_iface, dhcp_subnet, dhcp_netmask, dut_mac, '
              'and dut_address when using DHCP server. (At lease specify '
              'dhcp_iface and dut_mac if you accept defaults for rest options.')

  return options


def main():
  options = ParseOptions()
  CheckCall('sudo true #caching sudo')

  tftp_dir = tempfile.mkdtemp(prefix='tftp_')
  tftpd = None
  dhcpd = None

  if options.do_check_packages:
    CheckPackagesInstalled()

  if options.do_modify_netboot_ip:
    ModifyNetbootIP(options.host, options.initrd)

  if options.do_generate_image:
    GenerateImage(options.host, options.port, tftp_dir,
                  options.script, options.initrd, options.vmlinux)

  try:
    if options.do_tftp:
      tftpd = StartTFTPServer(options.host, tftp_dir)

    if options.do_dhcp:
      dhcpd = StartDHCPServer(options.dhcp_iface, options.host,
                              options.dhcp_subnet, options.dhcp_netmask,
                              options.dut_mac, options.dut_address,
                              options.script)

    if options.do_clone_miniomaha:
      options.miniomaha_dir = CloneMiniomaha(options.miniomaha_dir)

    if options.do_make_factory_package:
      MakeFactoryPackage(options.miniomaha_dir, options.board,
                         options.release, options.factory,
                         options.hwid_updater, options.firmware_updater)

    if options.do_miniomaha:
      StartMiniomahaServer(options.miniomaha_dir, options.port)
  finally:
    if tftpd:
      tftpd.kill()
    if dhcpd:
      dhcpd.kill()


if __name__ == '__main__':
  main()
