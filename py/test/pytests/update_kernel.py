# -*- coding: utf-8 -*-
#
# Copyright 2015 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Applies new kernel to DUT (for testing)."""

import logging
import os
import threading
import unittest

import factory_common  # pylint: disable=W0611
from cros.factory.device import device_utils
from cros.factory.test.test_ui import MakeLabel, UI
from cros.factory.test.ui_templates import OneScrollableSection
from cros.factory.utils.arg_utils import Arg

_TEST_TITLE = MakeLabel('Update Kernel', u'更新 Kernel')
_CSS = '#state {text-align:left;}'


class UpdateFirmwareTest(unittest.TestCase):
  ARGS = [
      # TODO(hungte) Support compressed image, or download from Omaha.
      Arg('resource_dir', str,
          ('Full path to resource directory for updating kernel, it should '
           'include new_kern.bin, boot/, firmware/, modules/'),
          default='/usr/local/factory/board/kernel_update/'),
  ]

  def setUp(self):
    self._ui = UI()
    self._template = OneScrollableSection(self._ui)
    self._template.SetTitle(_TEST_TITLE)
    self._ui.AppendCSS(_CSS)
    self.dut = device_utils.CreateDUTInterface()
    self.station = device_utils.CreateStationInterface()

  def runTest(self):
    self.CheckResourceDir()
    threading.Thread(target=self.UpdateKernel).start()
    self._ui.Run()

  def UpdateKernel(self):
    """Apply new kernel.

    Gets current kernel config, re-sign by make_dev_ssd, then write into system.
    """
    rootdev = self.dut.CheckOutput(["rootdev", "-s"]).strip()
    if rootdev.endswith('3'):
      kerndev = rootdev[:-1] + '2'
    elif rootdev.endswith('5'):
      kerndev = rootdev[:-1] + '4'
    else:
      self._ui.Fail('Unable to determine kernel location (%s)' % rootdev)
      return

    try:
      logging.info('Send kernel files to DUT')
      resource_dir = '/tmp/resource_dir'
      with self.station.temp.TempFile() as local_tarball:
        with self.dut.temp.TempFile() as remote_tarball:
          self.station.CheckCall(['tar', 'zcf', local_tarball,
                                  '-C', self.args.resource_dir, './'], log=True)
          self.dut.SendFile(local_tarball, remote_tarball)
          self.dut.Call(['rm', '-rf', resource_dir], log=True)
          self.dut.CheckCall(['mkdir', resource_dir], log=True)
          self.dut.CheckCall(['tar', 'zxf', remote_tarball, '-C', resource_dir],
                             log=True)

      if not self.LearnRemoteRO():
        logging.info('rootfs verification is off, update files in rootfs')
        self.dut.CheckCall(['mount', '-o', 'rw,remount', '/'], log=True)
        # kernels
        self.dut.CheckCall(['rsync', '-a', resource_dir + '/boot/', '/boot/'],
                           log=True)
        # TODO(stimim): update syslinux kernel
        # modules
        self.dut.CheckCall(['rsync', '-a', resource_dir + '/modules/',
                            '/lib/modules/'], log=True)
        # firmwares
        self.dut.CheckCall(['rsync', '-a', resource_dir + '/firmware/',
                            '/lib/firmware/'], log=True)

      logging.info('Update kernel partition %s', kerndev)
      self.UpdateKernelPartition(kerndev, resource_dir)
      logging.info('Done')
      self.dut.CheckCall(['sync'], log=True)
    except Exception:  # pylint: disable=broad-except
      logging.exception('Failed to update kernel')
      self._ui.Fail('Failed to update kernel')
    else:
      self._ui.Pass()

  def LearnRemoteRO(self):
    """Check if rootfs verification is on.

    Returns:
      true if it is on.
    """
    rootdev = self.dut.CheckOutput('rootdev')
    return rootdev.startswith('/dev/dm')

  def CheckResourceDir(self):
    """Check the layout of resource directory.

    The resource directory (self.args.resource_dir) should contain the following
    files:
        resource_dir/
        |-- boot/           (the /build/<board>/boot/ directory)
        |-- firmware/       (the /build/<board>/lib/firmware/ directory)
        |-- modules/        (the /build/<board>/lib/modules/ directory)
        `-- new_kern.bin    (new kernel partition image)

    The new_kern.bin is the kernel partition which is generated by
    vbutil_kernel.  You can use "~/trunk/src/scripts/update_kernel.sh" to update
    one device and read its kernel partition.

    Returns:
      True if everything is okay, will throw exception otherwise.
    """
    for subdir in ['', 'boot', 'firmware', 'modules', 'new_kern.bin']:
      path = os.path.join(self.args.resource_dir, subdir)
      self.assertTrue(os.path.exists(path), msg='%s is missing.' % path)
    return True

  def UpdateKernelPartition(self, kerndev, resource_dir):
    kernel_id = kerndev[-1:]

    # backup kernel config
    kernel_config = self.dut.CheckOutput(["dump_kernel_config", kerndev],
                                         log=True)
    self.dut.CheckCall(['dd', 'if=%s/new_kern.bin' % resource_dir,
                        'of=' + kerndev, 'bs=4K'], log=True)
    # write kernel config back
    config_suffix = ".%s" % kernel_id
    with self.dut.temp.TempFile(suffix=config_suffix) as config:
      self.dut.WriteFile(config, kernel_config)
      self.dut.CheckCall([
          '/usr/share/vboot/bin/make_dev_ssd.sh', '--partitions', kernel_id,
          '--set_config', config[:-len(config_suffix)]], log=True)
